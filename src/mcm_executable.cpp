//
// Created by nfiege on 12/7/23.
//

#include "mcm_executable.h"
#include <cstdlib>
#include <fstream>

mcm_executable::mcm_executable(const std::vector<std::vector<int>> &C, const std::string &new_path_to_executable,
                               const std::string &new_pre_cnf_file_args, const std::string &new_post_cnf_file_args,
                               const std::string &solver_log_filename, const std::string &solver_err_filename,
                               mcm::verbosity_mode verbosity,
                               bool allow_negative_numbers, bool write_cnf) :
        mcm(C, 1, verbosity, 1, allow_negative_numbers, write_cnf),
        path_to_executable(new_path_to_executable), pre_cnf_file_args(new_pre_cnf_file_args),
        post_cnf_file_args(new_post_cnf_file_args), solver_log_filename(solver_log_filename),
        solver_err_filename(solver_err_filename) {}

std::pair<bool, bool> mcm_executable::check() {
    // generate cnf file
    std::stringstream cnf_filename;
    cnf_filename << "temp.cnf";
    this->create_cnf_file(cnf_filename.str());
    // run solver with cnf file
    std::stringstream system_call;
    system_call << this->path_to_executable;
    if (!this->pre_cnf_file_args.empty()) {
        system_call << " " << this->pre_cnf_file_args;
    }
    system_call << " " << cnf_filename.str();
    if (!this->post_cnf_file_args.empty()) {
        system_call << " " << this->post_cnf_file_args;
    }
    //const std::string solver_log_filename = "solver_log.txt";
    //const std::string solver_err_filename = "solver_log.err";
    system_call << " 1>" << this->solver_log_filename << " 2>" << this->solver_err_filename;
    std::system(system_call.str().c_str());
    // read result file generated by solver
    bool timeout = true;
    bool sat = false;
    this->result_values.clear();
    std::ifstream result_file;
    result_file.open(this->solver_log_filename);
    std::string file_buffer;
    while(std::getline(result_file, file_buffer)) {
        std::stringstream ss;
        ss << file_buffer;
        std::string element_buffer;
        ss >> element_buffer;
        if (element_buffer.empty()) continue;
        if (element_buffer == "s") {
            element_buffer.clear();
            ss >> element_buffer;
            if (element_buffer == "SATISFIABLE") {
                sat = true;
                timeout = false;
            }
            else if (element_buffer == "UNSATISFIABLE") {
                sat = false;
                timeout = false;
            }
        }
        else if (element_buffer == "v") {
            while (true) {
                element_buffer.clear();
                ss >> element_buffer;
                if (element_buffer.empty()) break;
                int element_as_int = std::stoi(element_buffer);
                int value = (element_as_int>0)?(1):(0);
                int var_idx = std::abs(element_as_int);
                this->result_values[var_idx] = value;
            }
        }
    }
    result_file.close();
    // return decision
    return {sat, timeout};
}

void mcm_executable::reset_backend(mcm::formulation_mode mode) {
    mcm::reset_backend(mode);
    // nothing else to do
}

int mcm_executable::get_result_value(int var_idx) {
    return this->result_values.at(var_idx);
}
